<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Give Me Love</title>

    <style>
      :root {
        --bg-color: #ffffff;
        --text-color: #000000;
        --heart-color: #000000;
      }

      body {
        background-color: var(--bg-color);
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
        color: var(--text-color);
      }

      .message {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--text-color);
        letter-spacing: -0.03em;
        text-transform: lowercase;
        user-select: none;
        z-index: 10;
        margin-left: -50px; /* Offset roughly based on the screenshots where content is a bit left-aligned or centered, let's keep it centered for now */
      }

      .message:hover {
        opacity: 0.7;
      }

      #hearts-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        overflow: hidden;
        z-index: 0;
      }

      .heart {
        position: absolute;
        bottom: -50px;
        width: 30px;
        height: 30px;
        background-size: contain;
        background-repeat: no-repeat;
        animation: rise 10s infinite linear;
        opacity: 0;
      }

      @keyframes rise {
        0% {
          transform: translateY(10vh) scale(1);
          opacity: 0;
        }
        10% {
          opacity: var(--max-opacity, 1);
        }
        90% {
          opacity: var(--max-opacity, 1);
        }
        100% {
          transform: translateY(-110vh) scale(1.2);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="message">give me love</div>
    <div id="hearts-container"></div>

    <script>
      // const keyboardUIContainer = document.getElementById('keyboard-ui-container'); // Removed
      const heartsContainer = document.getElementById("hearts-container");

      const keyMap = {};
      let pressedKeys = [];

      // --- âš™ï¸ 1. í‚¤ë³´ë“œ ë ˆì´ì•„ì›ƒ ì •ì˜ (ë¹ ì ¸ìˆë˜ ë¶€ë¶„) ---
      // Keep keyboardLayout and keyDisplay for logical mapping, even if not rendered
      const keyboardLayout = [
        [
          "Escape",
          "F1",
          "F2",
          "F3",
          "F4",
          "F5",
          "F6",
          "F7",
          "F8",
          "F9",
          "F10",
          "F11",
          "F12",
        ],
        [
          "Backquote",
          "Digit1",
          "Digit2",
          "Digit3",
          "Digit4",
          "Digit5",
          "Digit6",
          "Digit7",
          "Digit8",
          "Digit9",
          "Digit0",
          "Minus",
          "Equal",
          "Backspace",
        ],
        [
          "Tab",
          "KeyQ",
          "KeyW",
          "KeyE",
          "KeyR",
          "KeyT",
          "KeyY",
          "KeyU",
          "KeyI",
          "KeyO",
          "KeyP",
          "BracketLeft",
          "BracketRight",
          "Backslash",
        ],
        [
          "CapsLock",
          "KeyA",
          "KeyS",
          "KeyD",
          "KeyF",
          "KeyG",
          "KeyH",
          "KeyJ",
          "KeyK",
          "KeyL",
          "Semicolon",
          "Quote",
          "Enter",
        ],
        [
          "ShiftLeft",
          "KeyZ",
          "KeyX",
          "KeyC",
          "KeyV",
          "KeyB",
          "KeyN",
          "KeyM",
          "Comma",
          "Period",
          "Slash",
          "ShiftRight",
        ],
        [
          "Function",
          "ControlLeft",
          "AltLeft",
          "MetaLeft",
          "Space",
          "MetaRight",
          "AltRight",
          "Arrows",
        ],
      ];

      const keyDisplay = {
        Escape: "esc",
        Backspace: "delete",
        Tab: "tab",
        CapsLock: "caps lock",
        Enter: "return",
        ShiftLeft: "shift",
        ShiftRight: "shift",
        ControlLeft: "control",
        AltLeft: "option",
        MetaLeft: "command",
        MetaRight: "command",
        AltRight: "option",
        Function: "fn",
        Backquote: "`",
        Digit1: "1",
        Digit2: "2",
        Digit3: "3",
        Digit4: "4",
        Digit5: "5",
        Digit6: "6",
        Digit7: "7",
        Digit8: "8",
        Digit9: "9",
        Digit0: "0",
        Minus: "-",
        Equal: "=",
        BracketLeft: "[",
        BracketRight: "]",
        Backslash: "\\",
        Semicolon: ";",
        Quote: "'",
        Comma: ",",
        Period: ".",
        Slash: "/",
        Space: "",
        ArrowUp: "â–²",
        ArrowLeft: "â—€",
        ArrowDown: "â–¼",
        ArrowRight: "â–¶",
      };

      // --- ğŸ¨ 2. í‚¤ë³´ë“œ UI ìƒì„± (ë¹ ì ¸ìˆë˜ ë¶€ë¶„) ---
      // This entire section for UI creation will be removed.
      // However, the keyMap still needs to be populated for heart detection logic.
      // So, I will create a simplified loop to populate keyMap without creating UI elements.

      // Simplified keyMap population
      keyboardLayout.forEach((row, rowIndex) => {
        row.forEach((key, colIndex) => {
          if (key === "Arrows") {
            keyMap["ArrowUp"] = { row: rowIndex, col: colIndex + 1 };
            keyMap["ArrowLeft"] = { row: rowIndex + 1, col: colIndex };
            keyMap["ArrowDown"] = { row: rowIndex + 1, col: colIndex + 1 };
            keyMap["ArrowRight"] = { row: rowIndex + 1, col: colIndex + 2 };
          } else {
            keyMap[key] = { row: rowIndex, col: colIndex };
          }
        });
      });

      let isHeartPink = false;

      function updateExistingHearts() {
        const hearts = document.querySelectorAll(".heart");
        hearts.forEach((heart) => {
          const color = isHeartPink
            ? `rgba(255, 105, 180, ${Math.random() * 0.5 + 0.5})`
            : `rgba(0, 0, 0, ${Math.random() * 0.2 + 0.1})`;
          const svgData = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="${color}" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;
          heart.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svgData)}')`;
        });
      }

      // --- â¤ï¸ 3. í•˜íŠ¸ íŒë… ë° í”¼ë“œë°± ë¡œì§ ---
      function checkHeartShape() {
        if (pressedKeys.length < 6) {
          resetKeyboard(false);
          return;
        }
        const coords = pressedKeys.map((k) => keyMap[k]).filter(Boolean);
        if (coords.length === 0) {
          resetKeyboard(false);
          return;
        }

        const minRow = Math.min(...coords.map((c) => c.row));
        const minCol = Math.min(...coords.map((c) => c.col));
        const relCoords = new Set(
          coords.map((c) => `${c.row - minRow},${c.col - minCol}`),
        );
        const heartShapes = [
          new Set(["0,1", "0,2", "1,0", "1,3", "2,0", "2,3", "3,1", "3,2"]),
          new Set(["0,1", "0,2", "1,0", "1,3", "2,1", "2,2", "3,1"]),
          new Set(["0,0", "0,2", "1,1", "2,0", "2,2", "3,1"]),
          new Set(["0,1", "0,3", "1,0", "1,4", "2,1", "2,3", "3,2"]),
        ];
        const matchedShape = heartShapes.find((shape) => {
          let matches = 0;
          relCoords.forEach((c) => {
            if (shape.has(c)) matches++;
          });
          return (
            matches >= shape.size * 0.8 && relCoords.size >= shape.size * 0.8
          );
        });

        if (matchedShape) {
          isHeartPink = true;
        } else {
          isHeartPink = false;
        }
        updateExistingHearts();
        resetKeyboard(true);
      }

      function resetKeyboard(isSuccess) {
        pressedKeys = [];
      }

      // --- ğŸ§ 4. í‚¤ ì…ë ¥ ê°ì§€ ë¦¬ìŠ¤ë„ˆ (ë¹ ì ¸ìˆë˜ ë¶€ë¶„) ---
      document.addEventListener("keydown", (e) => {
        e.preventDefault();
        const keyCode = e.code;

        if (keyCode === "Enter") {
          checkHeartShape();
          return;
        }
        if (keyCode === "Escape") {
          isHeartPink = false;
          updateExistingHearts();
          resetKeyboard(false);
          return;
        }

        // Simply push the key code to pressedKeys
        pressedKeys.push(keyCode);
      });

      // --- ğŸ‰ 5. ë°°ê²½ ì• ë‹ˆë©”ì´ì…˜ ---
      function createHeart() {
        const heart = document.createElement("div");
        heart.classList.add("heart");
        // Create a simple, minimal black/dark gray fill for the heart, or pink if detected
        const color = isHeartPink
          ? `rgba(255, 105, 180, ${Math.random() * 0.5 + 0.5})`
          : `rgba(0, 0, 0, ${Math.random() * 0.2 + 0.1})`;
        const svgData = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="${color}" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;
        heart.style.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(svgData)}')`;
        heart.style.left = `${Math.random() * 90 + 5}vw`;

        const duration = Math.random() * 5 + 8; // Bit faster and more straightforward
        heart.style.animationDuration = `${duration}s`;

        const size = Math.random() * 15 + 10;
        heart.style.width = `${size}px`;
        heart.style.height = `${size}px`;

        const maxOpacity = 1;
        heart.style.setProperty("--max-opacity", maxOpacity);

        heartsContainer.appendChild(heart);
        setTimeout(() => heart.remove(), duration * 1000);
      }
      setInterval(createHeart, 500);
    </script>
  </body>
</html>
